# for...in

Цикл for...in проходится по всем перечисляемым свойствам, прописанным строками (ключи-символы игнорируются). Переберет и все наследуемые перечисляемые свойства.
Пречисляемыми являются свойста, в дескрипторе которых флаг enumerable стоит в значении true.

**Параметры**

- variable. Принимает значение **имени свойства** на каждой итерации. Может быть обозначено через var, let или const. На каждой итерации будет создаваться новая переменная, поэтому нет разница, как именно была объеявлена переменная (разумеется, все правила работы с переменными в силе)
- object. Объект, чьи свойства будут перебираться в цикле.
- statement. Инструкция, которая будет выполнена на каждой итерации.

  **Описание**

  Цикл итерируется по всем перечисляемым свойства объекта, а также по перечисляемым свойствам объектов в прототипной цепочке. Так, и массив, и объект можно перебрать через for...in. Для массива в качестве переменной берутся индексы, для объекта - имена ключей.
  Цикл пройдется по все цепочке наследования. Однако методы вроде Array.prototype.indexOf или Object.prototype.toString не попадут в перебор, потому что они не являются перечисляемыми.

  **Перебор массива**

  При переборе массива в цикле for...in ключ будет являтся строкой, хотя в целом индекс массива (что и является ключом) - это число.

  ![image](https://github.com/AlinaLaniuk/interview/assets/101401177/76b243d8-151b-4414-809a-c1b3725b78fe)

  for...in переберет все свойства массива, даже если задать массиву любое нечисловое значение. Это возможно, потому что массив по своей природе является объектом. Однако использование строковых ключей в массиве - плохая и неиспользуемая практика. Нужно использовать сущность по назначению.
  ![image](https://github.com/AlinaLaniuk/interview/assets/101401177/515b7204-29b4-4c69-a4c5-f57924dc2fbd)

# for...of

Цикл for...of итерируется по значениям итерируемого объекта. Итерируемая сущность - сущность, у которой есть итератор. 

**Параметры**

- variable. Принимает значение свойства на каждой итерации. Может быть обозначено через var, let или const. На каждой итерации будет создаваться новая переменная, поэтому нет разница, как именно была объеявлена переменная (разумеется, все правила работы с переменными в силе)
- iterable. Сущность, чьи значения будут перебираться в цикле.
- statement. Инструкция, которая будет выполнена на каждой итерации.

**Описание**

Цикл работает в соответствии с итератором сущности. Оперирует значениями сущности. На каждой итерации мы работаем с конкретным значением этой итерации и производим некоторые инструкии, указанные в итераторе.
