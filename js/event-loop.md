# Event loop

**Общая архитектура браузера**

1. User interface - часть браузера, с которой пользователь взаимодействует. Все кнопочки, строка для урла, любые элементы, при помощи которых пользователь может управлять программой.
2. Browser engine - движок, соединительная часть между user interface и механизмом рендеринга.
3. Rendering engine - часть браузера, которая создает страницы, с которыми мы можем взаимодействовать. Именно этот движок будет обрабатывать код. Он строит DOM дерево, CSS дерево.
4. Networking - предназначено для работы с сетью. Отвечает за историю сайтов, которые посещали пользователь, доменные имена, взаимодействие с DNS сервером, обмен пакетами и т.д.
5. JS interpreter - это движок, который обрабатывает js-код. Самый популярный - V8. С помощью этого механизма работают и браузеры, и нода. Это независимый механизм, который позволяет обрабатывать js-код.
6. UI backend - подкапотная логика бэка для браузера.
7. Data persistence - хранилище данных. Local, session storage, webSQLБ файловая система (надо скачать/загрузить картинку), куки, работа с вкладками и т.д.

![image](https://github.com/AlinaLaniuk/interview/assets/101401177/6f7486bd-469f-402c-8735-22bcbe37538a)


Движки рендера, которые используются в браузерах:

- Webkit в Chrome
- Gekko в Firefox

**Архитектура движка рендера (webKit)**

Общая схема такая:

![image](https://github.com/AlinaLaniuk/interview/assets/101401177/10995e17-61d8-45ee-97a8-7f421bd9f2b0)

**Event Loop. Введение**

Event loop - это не часть JS, это механизм, который предоставляет хост-среда. Так, и в ноде, и в браузере js-код обрабатывается движком v8, однако механизм event loop реализован в этих средах по-разному. Event loop - это механизм, позволяющий использовать неблокирующую модель ввода и вывода. К примеру, это про то, чтобы на странице работала анимация, были кликабельны кнопки и куда надо отправлялись запросы. То есть фактически Event loop помогает нам сделать видимость параллельности выполнения задач. Но параллельно они выполнены, конечно, не будут.

**Call stack**

Это такая структура данных, в которую попадают функции в том порядке, в котором они должны быть вызваны. Организация структуры - классический стек - первый пришел, первый ушел. За его обработку отвечает движок JS (V8). 

![image](https://github.com/AlinaLaniuk/interview/assets/101401177/f802e8a4-4d99-41e0-a0da-f69edb528475)

В примере на картинке очередность выполнения будет такой: функция third внутри себя вызывает second, second вызывает third, а значит чтобы исполнить third мы должны вызвать две другие функции. В кол-стек эти функции лягут в том порядке, в котором должны быть вызваны для правильной работы кода.

Но кол-стек не бесконечен и он может быть переполнен. Если это произошло, приложение упадет.

 ![image](https://github.com/AlinaLaniuk/interview/assets/101401177/fb45d838-f1c0-4226-ba04-60742313e5d9)

**Task queue**

Task queue - структура, используемая в механизме event loop. Туда попадают отложенные задачи. Посмотрим на примере:

```
function log(value){
    console.log(value);
}

log('start');

setTimeout(() => {
    log('timeout');
}, 3000);

log('end');
```

Порядок логирования будет следующим:

1. Start
2. End
3. Timeout

Чтобы вызов любой функции произошел (неважно, синхронный это или ассинхронный код), функция должна попасть в колл стек. 
Вот что происходит при вызове функций:
1. В кол стек попадает вызов функции log('start').
2. В кол стек попадает вызов функции setTimeout.
3. Функция-колбек на данном этапе только запоминается браузером, регистрируется.
4. В кол стек попадает вызов функции log('end').
5. Браузер отсчитывает 3000 милисекунд и добавляет функцию-колбек из setTimeout в очередь задач. Если кол стек пустой, функция-колбек из очереди задач отправляется в кол стек и выполняется.

Нужно помнить, что:
1. Число, которое мы передаем вторым аргументом в setTimeout, не гарантирует выполнения функции ровно через это время. Браузер гарантирует, что фнукция-колбек попадет в очередь задач спустя заданное время, если это возможно, и как только ему удасться, он отправит эту функцию в кол стек и выполнит ее.
2. Таска из очереди задач будет отправлена в кол стек только **после того, как он станет пустым, т.е. все функции из кол стека будут выполнены**.

**Какие задачи решает движок JS?**

1. Куча (heap) и стек вызовов (call stack)
2. Работа с памятью (выделение и сбор мусора)
3. Компиляция JS  в машинный код
4. Оптимизация (кешиб скрытые классы и прочее)


**Как задачи попадают в очередь?**

За очередь задач отвечает event loop (механизм, принадлежащий хост-среде), а за кол стек - движок js (самый распространенный - v8).

Нужно понимать, что из инструментов разработки относится к JS, а что к стороннему API. Так, все таймауты, промисы, обработчики событий - это стороннее API, в частности, браузера. 

**Добавление обработчика события также пройдет через Event Loop**

```
const button1 = document.getElementById('button1');
const button2 = document.getElementById('button2');

button1.addEventListener('click', () => console.log('click button1'));
button2.addEventListener('click', () => console.log('click button2'));
```

Функции-колбеки будут зарегистрированны браузером. По нажатию на кнопку функция-колбек попадет в очередь задач и если в кол стеке ничего нет, пойдут на исполнение. Они будут зарегистрированы, пока не произойдет явное удаление обработчика через removeEventListener.

 ![image](https://github.com/AlinaLaniuk/interview/assets/101401177/db634613-b81a-44d5-a155-92359541b660)

**Микротакси и макротаски**

На самом деле у Event loop в распоряжении имеются две очереди - так называемые очереди макрозадач и микрозадач.

**Промисы всегда попадают в микротаски**. Порядок выволнения такой - сначала будут выолнены **все микротаски**, а после - **одна макротаска**.

```
log('1');

setTimeout(() => {
log('2')
}, 0);

Promise.resolve().then(() => {
log('3')
});

log('4');
```

В примере выше порядок такой:

1. Смотрим на синхронный код. Здесь синхронно будут выполнены log('1'), setTimeout(), Promise.resolve(), then(), log('4'). То есть мы понимаем, что в макро- и микротаски попадут не сами функции, предоставляющие нам ассинхронность, а колбеки в них. Итак, первым будет выполнен log('1')
2. Следующим в консоль выведится 4 от выполнения log('4')
3. Теперь разбираемся с колбеками. Микротаски выполнятся вперед макротасок, значит смотрим на промис. Промис уже был создан и уже резолвнулся, then также уже отработал. Однако колбек с логированием тройки попал в микротаски и после выполнения синхронного кода он первее колбека таймаута пойдет в кол стек. Итак, выведена тройка.
4. Теперь у нас пустая очередь микротасок, пустой кол бек, а значит, есть возможность выполнить одну макротаску. Скорее всего, браузер к этому моменту уже поместил колбек от таймаута в макротаски, так как интервал был задан нулевой. Значит, колбек просто ждет своей очереди на выполнение. Он помещается в кол стек и выполняется. Выведена 4.

Подытожим механизм выполнения тасок в Event Loop:
1. Сначала выполняются все синхронные операции до очищения кол стека
2. Далее будут выполнены все микротаски
3. В работу берется одна макротаска. Если макротаски порождают микротаски, вперед будут выполнены все микротаски, только после этого в ход пойдет следующая макрозадача.
4. Повторяется по кругу.

**Микротаски**

В очередь микротасок попадают:
1. Промисы
2. queueMicrotask - функционал для создания микротасок вручную
3. mutationObserver - специальный инструмент для слежения за нодами

**Макротаски**

В очередь макротасок попадают:
1. Таймеры (setTimeout, setInterval)
2. События (клики, загрузка изображений и т.д.)
3. Браузерные нюансы (рендер, input/output, т.д.)

**Как происходит рендеринг**

1. Построение DOM, CSSOM, Render tree.
2. Калькуляция стилей. Применение селекторов к элементам. Важно помнить, что чем сложнее селектор - тем дольше этот этап будет проходить.
3. Layout tree. Выстраивание макета, чертежа страницы. По размерам и позиции выставляются все эелемнты.
4. Paint. Рисует из чертежа пиксели.
5. Compositing. Работа со слоями.

Манипуляции с нодами приводят к частичному или полному перерендеру (в зависимости от того, какая совершается операция и с какой именно нодой). И это очень дорогостоящая процедура.

Вот какие операции приводят к перерендеру:
- изменение размера окна (resize)
- изменение шрифта
- измнение контента
- добавление/удаление классов/стилей
- манипуляции с DOM (удаление/добавление нод)
- изменение ориентации (альбом/книга, то есть поворот экрана)
- изменение размеров/позиции элемента (затрагивает только сам элемент)
- вычисление размеров/позиций

Рендеринг также влияет на работу Event Loop. Это внутренняя машинерия, которую нужно изучать отдельно, если такая необходимость есть. Как правило, браузер хорошо умеет в оптимизацию, и он оптимально может распределять зхадачи по своим очередям. Кроме того, мы как разработчики особо повлиять на это не можем.



