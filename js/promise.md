# Что такое Promise?

Объект Promise - это класс, который используется для отложенных вычислений.

1. Принимает функцию executor.
2. Функция executor выполнится сразу, до того как конструктор вернет созданный объект.
3. Функция executor в свою очередь принимает два параметра - функцию resolve (вызовет успешное исполнение промиса) и функцию reject (неуспешное выполнение промиса).
4. Возвращаемое значение функции executor игнорируется.

**Статические методы промисов**

1. **Promise.resolve и Promise.reject**. Методы, которые возвращают резолвнутый или реджекнутый промис. При этом речь не идет про резолв или реджект другого промиса. Этот метод только создает с каким-то значением промис.

Promise.resolve принимает значение, с которым будет резолвнут возвращаемый методом промис. Может принимать любое значение, thenable объект (объект с методом, который называет then) и промис. В случае, если это промис - этот промис и будет возвращен. Если это thenable объект, будет следовать переданному объекту.
Promise.reject принимает причину, из-за который промис будет резолвнут (чаще всего это инстанс ошибки).


2. **Promise.all**. В качестве аргумента принимает итерируемую сущность (например, массив). Возвращает собственный промис. Какие есть варианты:
 - Передан массив промисов, все выполнились успешно. Вернет свой fulfilled промис, его значением будет массив значений, которые были отданы промисами из переданного массива. Возвращаемый массив значений будет хранить значения в порядке оригинальногт массива, вне зависимости от того, в каком порядке промисы были выполнены.
 - Передан массив промисов, хотя бы один был отклонен. Вернет свой отклоненный промис с причиной, по которой был отклонен промис из переданного массива (речь идет про первый, потому что выполнение функции закончится на первом отклоненном промисе). Все резолвнутые до него промисы будут проигнорированы.
 - Передан массив данных, при этом хотя бы один или все эелементы не являются промисами. Такие значения будут обернуты в Promise.resolve, то есть на их месте мы получим резолвнутые промисы.
 - Передан пустой массив. Резолвнится со значением пустого массива.
 - Передан любой неитерируемый объект. Свалится с ошибкой.

3. **Promise.allSettled**. Принимает итерируемый объект (например, массив). Значения внутри итерируемого объекта могут быть любыми (что будет с разными типами значений в массиве, смотри выше. Здесь все то же самое). Вернет промис, завершенный успешно, в любом случае, даже если какие-то промисы в переданном аргументе реджекнутся. Однако надо понимть, что промис вернется резолвнутым только в случае, если все промисы внутри будут завершены, успешно или нет. Если какой-то промис pending, то и промис, который возвращает метод, также будет pending. Резолвнится со значением массива, елементами которого будут объекты. Эти объекты состоят из полей status(статус промиса) и value(значение, с которым промис резолвнулся или отклонился.)

4. **Promise.any**. Принимает итерируемый объект. Вернет промис с одним значением: в случае, если хотя бы один промис завершился успешно, промис метода будет fullfilled, его значением станет значение первого резолвнутого промиса; в случае, если все промисы будут отклонены, промис метода вернется со статусом rejected, а значением станет либо массив, содержащий причины ошибок, или AggregateError (подкласс Error, который объединяет выброшенные ошибки вместе).

5. **Promise.race**. Принимает итерируемый объект. Возвращает выполненный или реджекнутый промис, в зависимости от того, с каким статусом и значением вернется первый завершенный промис.

**Прототипные методы промисов**

1. **Promise.prototype.then**.

Принимает два аргумента - функции onFulfilled и onRejected (обычно функции, вернее, но может быть чем угодно. В таком случае лучше чекнуть, что получится). Первая будет вызвана, когда промис будет выполнен. Вторая - когда отклонен. onFulfilled принимает значение, с которым промис будет выполнен, onRejected - причину, с которым промис будет отклонен.

Примеры:

```
new Promise((resolve, reject) => resolve('sun')).then((result) => result);
```

Результат - резолвнутый промис со значением 'sun'.

```
Promise.reject(new Error('oops')).then((result) => {return result}, (error) => {return error});
```
Результат - резолвнутый промис, значение - объект ошибки. Так происходит потому, что вторая фнукция then (на отклонение) возвращает ошибку. Из then вернется отклоненный промис, если в функции на отклонения выбрасывается ошибка или возвращается отклоненный промис.

```
Promise.reject(new Error('oops')).then((result) => {return result}, (error) => {throw error});
Promise.reject(new Error('oops')).then((result) => {return result}, (error) => {return Promise.reject()});
```

Результат - отклоненный промис. 

```
new Promise((resolve, reject) => resolve('sun')).then((result) => Promise.resolve('moon'));
```

Вернется успешно выполненный промис со значением moon. Потому что если ренернить промис, то именно от станет новым значением.

2. **Promise.prototype.catch**. Возвращает промис, работает только в случае, если промис, к которому этот метод применяется, отклонен. Ведес себя как Promise.prototype.then(undefined, onRejected).

3. **Promise.prototype.finally**. Если этот метод стоит в цепочке, он однозначно будет выполнен. Принимает функцию, которая будет выполнена вне зависимости от того, был выполнен промис успешно и отклонен. У этого метода много тонкостей, лучше чекать отдельно.
